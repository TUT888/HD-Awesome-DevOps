name: Develop Branch CD - Deploy to production Environment

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      version:
        description: 'Semantic version for deployment (e.g., v1.2.3)'
        required: true
        type: string

env:
  SHARED_ACR_LOGIN_SERVER: ${{ secrets.SHARED_ACR_LOGIN_SERVER }}
  SHARED_ACR_NAME: ${{ secrets.SHARED_ACR_NAME }}

  RESOURCE_GROUP_production: sit722alicestd-production-rg
  AKS_CLUSTER_production: sit722alicestd-production-aks
  AZURE_LOCATION: australiaeast

  # Image Scan with Trivy
  # 1: Fail the build, stop the job if vulnerabilities found
  # 0: Don't fail the build, just report security scan result (for learning purpose, I'll use this option)
  IMAGE_SECURITY_GATE: 0

jobs:
  # Build images
  build-images:
    name: Build and Scan images for all services
    runs-on: ubuntu-latest
    
    outputs:
      GIT_SHA: ${{ steps.vars.outputs.GIT_SHA }}
      IMAGE_TAG: ${{ steps.vars.outputs.IMAGE_TAG }}
      NOTES_SERVICE_IMAGE: ${{ steps.output_images.outputs.notes_service_image }}
      USERS_SERVICE_IMAGE: ${{ steps.output_images.outputs.users_service_image }}
      FRONTEND_IMAGE: ${{ steps.output_images.outputs.frontend_image }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
      
      # Get image tag with Git SHA, start building and scanning images
      - name: Set variables (Short Git SHA and Image tag)
        id: vars
        run: |
          echo "GIT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=prod-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      # Start building images
      - name: Build Images
        run: |
          # Set image name based on Git SHA
          NOTES_SERVICE_IMAGE="notes_service:${{ steps.vars.outputs.IMAGE_TAG }}"
          USERS_SERVICE_IMAGE="users_service:${{ steps.vars.outputs.IMAGE_TAG }}"
          FRONTEND_IMAGE="frontend:${{ steps.vars.outputs.IMAGE_TAG }}"

          # Semantic version images
          NOTES_SERVICE_IMAGE_VERSION="notes_service:${{ inputs.version }}"
          USERS_SERVICE_IMAGE_VERSION="users_service:${{ inputs.version }}"
          FRONTEND_IMAGE_VERSION="frontend:${{ inputs.version }}"

          # Build local images for scanning
          docker build -t $NOTES_SERVICE_IMAGE -t $NOTES_SERVICE_IMAGE_VERSION ./backend/notes_service
          docker build -t $USERS_SERVICE_IMAGE -t $USERS_SERVICE_IMAGE_VERSION ./backend/users_service
          docker build -t $FRONTEND_IMAGE -t $FRONTEND_IMAGE_VERSION ./frontend

          # Set image names as GitHub env variables, allowing internal reference within the same job
          echo "NOTES_SERVICE_IMAGE=$NOTES_SERVICE_IMAGE" >> $GITHUB_ENV
          echo "USERS_SERVICE_IMAGE=$USERS_SERVICE_IMAGE" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE=$FRONTEND_IMAGE" >> $GITHUB_ENV

          echo "NOTES_SERVICE_IMAGE_VERSION=$NOTES_SERVICE_IMAGE_VERSION" >> $GITHUB_ENV
          echo "USERS_SERVICE_IMAGE_VERSION=$USERS_SERVICE_IMAGE_VERSION" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE_VERSION=$FRONTEND_IMAGE_VERSION" >> $GITHUB_ENV

      # Scan images with Trivy
      - name: Scan Images
        run: |
          echo "Scanning Notes Service Image: ${{ env.NOTES_SERVICE_IMAGE_VERSION }}..."
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image --scanners vuln --severity HIGH,CRITICAL --exit-code ${{ env.IMAGE_SECURITY_GATE }} \
            ${{ env.NOTES_SERVICE_IMAGE_VERSION }}

          echo "Scanning Users Service Image: ${{ env.USERS_SERVICE_IMAGE_VERSION }}..."
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image --scanners vuln --severity HIGH,CRITICAL --exit-code ${{ env.IMAGE_SECURITY_GATE }} \
            ${{ env.USERS_SERVICE_IMAGE_VERSION }}

          echo "Scanning Frontend Image: ${{ env.FRONTEND_IMAGE_VERSION }}..."
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image --scanners vuln --severity HIGH,CRITICAL --exit-code ${{ env.IMAGE_SECURITY_GATE }} \
            ${{ env.FRONTEND_IMAGE_VERSION }}
          
      # All check passed, start pushing images to ACR
      - name: Log in to ACR
        run: |
          az acr login --name ${{ env.SHARED_ACR_LOGIN_SERVER }}

      - name: Tag and Push Images
        id: output_images
        run: |
          # Tag images
          docker tag $NOTES_SERVICE_IMAGE ${{ env.SHARED_ACR_LOGIN_SERVER }}/$NOTES_SERVICE_IMAGE
          docker tag $USERS_SERVICE_IMAGE ${{ env.SHARED_ACR_LOGIN_SERVER }}/$USERS_SERVICE_IMAGE
          docker tag $FRONTEND_IMAGE ${{ env.SHARED_ACR_LOGIN_SERVER }}/$FRONTEND_IMAGE

          docker tag $NOTES_SERVICE_IMAGE_VERSION ${{ env.SHARED_ACR_LOGIN_SERVER }}/$NOTES_SERVICE_IMAGE_VERSION
          docker tag $USERS_SERVICE_IMAGE_VERSION ${{ env.SHARED_ACR_LOGIN_SERVER }}/$USERS_SERVICE_IMAGE_VERSION
          docker tag $FRONTEND_IMAGE_VERSION ${{ env.SHARED_ACR_LOGIN_SERVER }}/$FRONTEND_IMAGE_VERSION

          # Push images
          docker push ${{ env.SHARED_ACR_LOGIN_SERVER }}/$NOTES_SERVICE_IMAGE
          docker push ${{ env.SHARED_ACR_LOGIN_SERVER }}/$USERS_SERVICE_IMAGE
          docker push ${{ env.SHARED_ACR_LOGIN_SERVER }}/$FRONTEND_IMAGE

          docker push ${{ env.SHARED_ACR_LOGIN_SERVER }}/$NOTES_SERVICE_IMAGE_VERSION
          docker push ${{ env.SHARED_ACR_LOGIN_SERVER }}/$USERS_SERVICE_IMAGE_VERSION
          docker push ${{ env.SHARED_ACR_LOGIN_SERVER }}/$FRONTEND_IMAGE_VERSION

          # Export image name (with semantic versioning tag) as output
          echo "notes_service_image=$NOTES_SERVICE_IMAGE_VERSION" >> $GITHUB_OUTPUT
          echo "users_service_image=$USERS_SERVICE_IMAGE_VERSION" >> $GITHUB_OUTPUT
          echo "frontend_image=$FRONTEND_IMAGE_VERSION" >> $GITHUB_OUTPUT

  # Deploy services to production AKS
  deploy-to-production:
    name: Deploy to production environment
    runs-on: ubuntu-latest
    needs: build-images
    
    outputs:
      NOTES_SERVICE_IP: ${{ steps.get_backend_ips.outputs.notes_ip }}
      NOTES_SERVICE_PORT: ${{ steps.get_backend_ips.outputs.notes_port }}
      USERS_SERVICE_IP: ${{ steps.get_backend_ips.outputs.users_ip }}
      USERS_SERVICE_PORT: ${{ steps.get_backend_ips.outputs.users_port }}
      FRONTEND_IP: ${{ steps.get_frontend_ip.outputs.frontend_ip }}
      FRONTEND_PORT: ${{ steps.get_frontend_ip.outputs.frontend_port }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true
      
      - name: Set Kubernetes context (get AKS credentials)
        run: |
          az aks get-credentials \
            --resource-group ${{ env.RESOURCE_GROUP_production }} \
            --name ${{ env.AKS_CLUSTER_production }} \
            --overwrite-existing
      
      - name: Deploy Backend Infrastructure (ConfigMaps, Secrets, Databases)
        run: |
          kubectl apply -f k8s/production/configmaps.yaml
          kubectl apply -f k8s/production/secrets.yaml
          kubectl apply -f k8s/production/notes-db-deployment.yaml
          kubectl apply -f k8s/production/users-db-deployment.yaml
      
      - name: Deploy Backend Microservices
        run: |
          # Update image tag in deployment manifest, using the specific git SHA version 
          echo "Updating image tag in deployment manifest..."
          sed -i "s|_IMAGE_NAME_WITH_TAG_|${{ env.SHARED_ACR_LOGIN_SERVER }}/${{ needs.build-images.outputs.NOTES_SERVICE_IMAGE }}|g" k8s/production/notes-service-deployment.yaml
          sed -i "s|_IMAGE_NAME_WITH_TAG_|${{ env.SHARED_ACR_LOGIN_SERVER }}/${{ needs.build-images.outputs.USERS_SERVICE_IMAGE }}|g" k8s/production/users-service-deployment.yaml

          echo "Deploying backend services to AKS..."
          kubectl apply -f k8s/production/users-service-deployment.yaml
          kubectl apply -f k8s/production/notes-service-deployment.yaml

      - name: Wait for Backend LoadBalancer IPs
        env:
          ENVIRONMENT: production
        run: |
          chmod +x .github/scripts/get_backend_ip.sh
          ./.github/scripts/get_backend_ip.sh

      - name: Capture Backend IPs for Workflow Output
        id: get_backend_ips
        run: |
          echo "notes_ip=${{ env.NOTES_IP }}" >> $GITHUB_OUTPUT
          echo "notes_port=${{ env.NOTES_PORT }}" >> $GITHUB_OUTPUT
          echo "users_ip=${{ env.USERS_IP }}" >> $GITHUB_OUTPUT
          echo "users_port=${{ env.USERS_PORT }}" >> $GITHUB_OUTPUT
      
      # Frontend
      - name: Inject Backend IPs into Frontend main.js
        run: |
          echo "Injecting IPs into frontend/static/js/main.js"
          # Ensure frontend/main.js is directly in the path for sed
          sed -i "s|http://localhost:5000|http://${{ env.NOTES_IP }}:${{ env.NOTES_PORT }}|g" frontend/main.js
          sed -i "s|http://localhost:5001|http://${{ env.USERS_IP }}:${{ env.USERS_PORT }}|g" frontend/main.js
          
          # Display the modified file content for debugging
          echo "--- Modified main.js content ---"
          cat frontend/main.js
          echo "---------------------------------"

      - name: Deploy Frontend to AKS
        run: |
          # Update image tag in deployment manifest, using the specific git SHA version 
          echo "Updating image tag in deployment manifest..."
          sed -i "s|_IMAGE_NAME_WITH_TAG_|${{ env.SHARED_ACR_LOGIN_SERVER }}/${{ needs.build-images.outputs.FRONTEND_IMAGE }}|g" k8s/production/frontend-deployment.yaml

          # Student Subscription only allow 2 public IP address, so as a demo, I remove the notes service
          kubectl delete -f k8s/production/notes-service-deployment.yaml

          # Apply frontend deployment
          echo "Deploying frontend to AKS..."
          kubectl apply -f k8s/production/frontend-deployment.yaml
      
      - name: Wait for Frontend LoadBalancer IP
        env:
          ENVIRONMENT: production
        run: |
          chmod +x .github/scripts/get_frontend_ip.sh
          ./.github/scripts/get_frontend_ip.sh

      - name: Capture Frontend IP for Workflow Output
        id: get_frontend_ip
        run: |
          echo "frontend_ip=${{ env.FRONTEND_IP }}" >> $GITHUB_OUTPUT
          echo "frontend_port=${{ env.FRONTEND_PORT }}" >> $GITHUB_OUTPUT

  backend-smoke-tests:
    name: Backend smoke tests
    runs-on: ubuntu-latest
    needs: deploy-to-production
    
    strategy:
      matrix:
        service:
          - name: notes_service
            external_ip: ${{ needs.deploy-to-production.outputs.NOTES_SERVICE_IP }}
            service_port: ${{ needs.deploy-to-production.outputs.NOTES_SERVICE_PORT }}
            expected_output: "Welcome to the Notes Service!"
          - name: users_service
            external_ip: ${{ needs.deploy-to-production.outputs.USERS_SERVICE_IP }}
            service_port: ${{ needs.deploy-to-production.outputs.USERS_SERVICE_PORT }}
            expected_output: "Welcome to the Users Service!"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Run Backend Smoke Tests
        env:
          TEST_IP: ${{ matrix.service.external_ip }}
          TEST_PORT: ${{ matrix.service.service_port }}
          EXPECTED_MESSAGE: ${{ matrix.service.expected_output }}
        run: |
          chmod +x .github/scripts/backend_smoke_tests.sh
          ./.github/scripts/backend_smoke_tests.sh

  frontend-smoke-tests:
    name: Frontend smoke tests
    runs-on: ubuntu-latest
    needs: deploy-to-production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Run Backend Smoke Tests
        env:
          TEST_IP: ${{ needs.deploy-to-production.outputs.FRONTEND_IP }}
          TEST_PORT: ${{ needs.deploy-to-production.outputs.FRONTEND_PORT }}
        run: |
          chmod +x .github/scripts/frontend_smoke_tests.sh
          ./.github/scripts/frontend_smoke_tests.sh

  # Deployment result
  summary:
    runs-on: ubuntu-latest
    needs: [backend-smoke-tests, frontend-smoke-tests]
    
    steps:   
      - name: Checkout repository
        uses: actions/checkout@v4
            
      - name: Deployment result
        run: |
          echo "All checks passed"
          echo "Deployment success!"
      